# DP-2

### 모든 쌍 최단 경로

##### 다음 각 정점 사이의 최단 경로는 얼마인가? 1에서 2까지의 최단 경로 값은 4이며, 1에서 5까지의 최단 경로 값은 8이다. 다른 정점 사이의 최단 경로 값들은 얼마인가?

#### 가중치 방향 그래프

- 정점(vertex, node)
- 간선(edge, arc)
- 가중치(weight)
- 경로(path)
  - 단순 경로(Simple path)

- 순환(cycle)
  - 순환(cycle) 그래프
  - 비순환(acycle) 그래프
- 길이(length)
- 인접 정점(adjacent vertex)



### 최단 경로(Shortest Path)



#### 한 도시에서 다른 도시로 직항로가 없는 경우 가장 빨리 갈 수 있는 항로를 찾는 문제

#### 가중치 포함, 방향성 그래프에서 최단 경로 찾기

#### 최적화 문제(optimization problem)

- 주어진 문제에 대하여 하나 이상의 많은 해답이 존재할 때, 이 가운데에서 가장 최적인 해답(optimal solution)을 찾아야 하는 문제



#### brute-force 접근 방법

- 한 정점에서 다른 정점으로의 모든 경로의 길이를 구한 뒤, 그들 중에서 최소길이를 찾는다.
- 그래프가 n개의 정점을 가지고 있고, 완전 그래프라고 가정하면
- 한 정점 i에서 어떤 정점 j로 가는 경로들을 다 모아 보면, 그 경로들 중에서 나머지 모든 정점을 한번씩은 꼭 거쳐서 가는 경로들도 포함되어 있는데, 그 경로들의 수만 우선 계산해보자
- i에서 출발하여 처음에 도착할 수 있는 정점의 가지 수는 n-2개이고, 그 중에 하나를 선택하면, 그 다음에 도착할 수 있는 정점의 가지 수는 n-3개 이고, 이렇게 계속하여 계산해보면, 총 경로의 개수는(n-2)(n-3)...1 = (n-2)!이 된다.
- 이 경로의 개수만 보아도 지수보다 훨씬 크므로, 이 알고리즘은 절대적으로 비효율적이다!

#### DP 접근 방법

##### 이 문제를 해결하려면, 각 점을 시작점으로 정하여 다익스트라의 최단 경로 알고리즘을 수행하면 된다.

##### 이떄의 시간 복잡도는 배열을 사용하면 (n-1)xO(n*2) = O(n*3)이다. 단, n은 점의 수이다.

##### Warshall은 그래프에서 모든 쌍의 경로 존재여부( transitive closure)를 찾아내는 동적 계획 알고리즘을 제안했고, Floyd는 이를 변형하여 모든쌍 최단 경로를 찾는 알고리즘을 고안하였다.

##### 따라서 모든 쌍 최단 경로를 찾는 동적 계획 알고리즘을 플로이드-워샬 알고리즘이라 한다.(간단하게 플로이드 알고리즘)

##### 플로이드 알고리즘의 시간 복잡도는 O(n ** 3)으로 다익스트라 알고리즘을 (n-1)번 사용할 때의 시간 복잡도와 동일하다.

##### 그러나 플로이드 알고리즘은 매우 간단하여 다익스트라 알고리즘을 사용하는 것보다 효율적이다.



##### 동적 계획 알고리즘으로 모든 쌍 최단 경로 문제를 해결하려면 먼저 부분문제들을 찾아야한다.

##### 이를 위해 일단 그래프의 점의 수가 적을 때를 생각해보자.

##### 그래프에 3개의 점이 있는 경우, 점 i에서 점 j까지의 최단 경로를 찾으려면 2가지 경로, 즉, 점 i에서 점 j로 직접 가는 경로와 점 1을 경유하는 경로 중에서 짧은 것을 선택하면 된다.



#### 모든 쌍 최단 경로알고리즘

```c
D[i][j] = 선분 (i, j)의 가중치,
출력: 모든 쌍 최단 경로의 거리를 저장한 2-d 배열 D
AllPairsShortest(D[][])
    FOR k in 1 -> n
    	FOR i in 1 -> n (단, i != k)
    		FOR j in 1 -> n  (단, j != k, j != i)
    			D[i][j] <- min(D[i][k] + D[k][j], D[i][j])
```



 ###  swea 2383 .[[모의 SW 역량테스트\] 점심 식사시간](javascript:clickProblem('AV5-BEE6AK0DFAVl','PROBLEM');)

슈더 코드

```markdown
- 사람 별로 가는 계단을 정한다.
- 계단에 도착하는 시간별 인원 기록
시간 1 2 3 4
인원   2 2

- 내려가는 시간별 인원을 기록
시간 1 2 3 4 5 6 7 8 9
인원     1 1 1
         2 2 2
           3 3 1
               2 1 1
```









