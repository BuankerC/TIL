## 위상 정렬

- 앞의 1, 3이 처리되어야 2번을 처리할 수 있는 경우
  - 정점의 진입 차수를 활용
  - 진입 차수가 0인 정점부터 시작
  - 정점을 처리할 때 인접 정점에 처리되었음을 알림
    - 인접 정점의 진입 차수를 하나 줄임
    - 진입 차수가 0이 되면 다음 번에 처리할 차례가 됨



#### 연습문제

- 6명의 사람이 각자 갖고 있는 100원짜리 동전의 개수를 비교했더니 다음과 같은 조건이 되었다. 1번과 6번이 갖고 있는 금액이 100원이었다면, 가장 많은 동전을 가진 사람은 최소한 몇개의 동전을 갖고 있었는가?

1 < 2

1 < 3

3 < 2

6 < 3

3 < 4

5 < 4

2 < 5

``` c
Sort()
    for i : 0 -> N  // 진입차수가 0이면 enQ
        if(I[i] == 0)
            enQ(i)
    while(is_not_emptyQ())
        n = deQ()
        visit(n)  // 노드에서 해야할 일
        for i : 1 -> N
            if(A[n][i] == 1)
                I[i]  // n의 인접노드 진입차수 감소
                if(I[i] == 0) // 진입차수가 0이면  enQ
                    enQ(i)
```

- 1~V까지 각 사람을 노드로 표시
- 노드 별 동전 수를 저장하는 배열  coin[], 선언, 0으로 초기화
- visit(n)
  - 노드 n으로 진입하는 모든 노드 i에 대해, coin[i]의 최대갑 + 1을  coin[n]으로 정함. 진입하는 노드가 없는 경우 동전 수는 1이 됨

```c
visit(n):
max = 0 ;
for i : 1 -> V
of(adk[j][n] != 0)
    if(max < coin[i])
        max = coin[i]
coin[n] = max + 1;
```

이 문제의 경우, 진입차수 0인 노드 i는 coin[i]  = 1, while에서는 visit(n) 대신 enQ(i) 후에