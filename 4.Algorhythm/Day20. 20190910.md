## 힙(heap)

**완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조**

**최대 힙(max heap)**

- 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
- {부모노드의 키 값 > 자식노드의 키 값}
- 루트 노드 : 키 값이 가장 큰 노드

**최소 힙(min heap)**

- 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
- {부모노드의 키 값 < 자식 노드의 키 값}
- 루트 노드 : 키 값이 가장 작은 노드

### 힙 연산 - 삭제

**힙에서는 루트 노드의 원소만을 삭제할 수 있다.**

**루트 노드의 원소를 삭제하여 반환한다.**

**힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다.**



아ㅏㅏㅏㅏㅏㅏ

A형 2번 슈더코드

```python
'''
각 섬 사이의 거리를 저장한 인접행렬 adj[][]를 만든다.

MST(최소 스패닝 트리)의 거리 합계를 구한다. MST에 포함되지 않은 섬이 있으면 -1을 출력한다.
MST의 최소합계를 찾는 알고리즘(프림, 크루스컬) 중 하나를 적용해본다.
프림 알고리즘의 경우
(1) 1번 노드를 MST에 포함 mst[1] = 1
(2) MST에 포함된 노드에 인접하고,
아직 MST에 포함되지 않은 노드 중 거리가 최소인 노드를 선택하고, MST에 포함시킨다.
(3) (2)를 반복한다. 선택되는 노드가 없는 경우 중지
(4) 모든 노드가 MST에 포함되어 있으면 거리의 합을 출력. 
포함되지 않은 노드가 있으면 -1 출력
'''
```



## swea 1248. [S/W 문제해결 응용] 3일차 - 공통조상 D5

슈더코드

```python
'''
(1) 자식을 인덱스로 부모 저장
(2) N1의 조상 i를 빈 배열 a에 표시 a[i] = 1
(3) N2의 조상 j를 배열 a에서 확인 (a[j] == 1인 경우)
(4) a[j] == 1인 최초의 경우가 N1, N2에서 가장 가까운 공통 조상
'''

c = N1
while(par[c] != 0):
    a[par[c]] = 1
    c = par[c]
c = N2
while(a[c] == 0):
    c = par[c]
print(c)
```



