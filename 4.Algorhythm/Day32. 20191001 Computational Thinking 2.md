## 2. 수와 표현

- 약간의 설명
  - 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
  - k개의 비트를 사용하면 0부터 2**k  - 1까지 표현 가능
  - 사실, 꼭 저 범위인 것은 아님. 약속하는 방식에 따라 다르지만, 어떤 경우든 최대 2 ** k 가지의 값을 표현하는 것이 가능
  - 10진수로 k자리를 쓰면 0부터 10 ** k - 1까지 표현이 가능한 것과 완전히 동일한 과정



- - 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
  - 2 ** k - 1 >= n이 성립해야 함 -> 즉, 2 ** k >= n + 1
  - 같은 의미로, k >= log(n + 1) -> 약 log n 비트가 필요
  - x = logn과 2 ** x = n은 같은 말



- - <u>위의 식을 잘 보면, logn이란(출제 가능!!)</u>
    - **<u>2의 몇 승이 n이 되느냐의 답</u>**
    - **<u>n을 표현하는 데 몇 비트가 필요한가의 답</u>**
    - **<u>1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐의 답</u>**
    - **<u>n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답</u>**
  -  x = logn일 때 x와 n을 비교하면 x가 더 작고, n이 커질수록 엄청나게 달라진다.
  - 100자리로 표현할 수 있는 10진수 값은 읽을 수도 없을 정도로 큰 값이다.
  - 컴퓨터 분야에서 로그의 밑은 항상 2
  - 32비트 컴퓨터의 주소 공간은 2 ** 32 = 약 40억개 주소
  - n + (n/2 + n/2) + (n/4 + n/4+ n/4 + n/4) + (n/8 + n/8 + ...) + ... + (1 + 1 + ...) = nlog(n+1)
  - n + n/2 + n/4 + ... + 1 = 2n
  - 위 두 식의 항의 개수는 logn + 1개

| 상수 법칙    | loga1 = 0,logaA = 1                       |
| ------------ | ----------------------------------------- |
| 덧셈 법칙    | logaXY = logaX + logaY                    |
| 뺄셈 법칙    | loga X/Y = logaX - logaY                  |
| 지수 법칙    | logaX**b = b logaX                        |
| 밑 변환 법칙 | logbX = logkX / logkB (단, k > 0, k != 1) |
| 역수 법칙    | logbX = 1/logxB (단, b != 1)              |

### 문제들

- 문제 1 : 2진수 표현에서 logn 비트로 표현할 수 있는 숫자 범위는?

x = 2 ** n,  logX = n

logn = x

x = n ** log2



답 : n

- 문제 2 : 스무고개가 이상적으로 진행된다고 할 때, 맞출 수 있는 답의 종류는 몇 가지인가?



- 문제 3 : n이 충분히 큰 값일 때 다음 중 어느 값이 더 큰가? 각 쌍에 대해 비교하고 그 이유를 작성하시오.

1. 2n ( < ) n **2

2. 2 ** (n/2)  ( < ) √3 ** n = 3 ** (n/2)  1기때 시험출제!!

3. 2 ** (nlogn) = 2 ** n  ( > )  n!

4. log2 ** 2n  ( < )  n√n  -> 2nlog2 (  )  n√n,   2  ( < )  √n



- 문제 4 : x = logaYZ일 때 x를 2를 밑으로 하는 로그들로 표현하시오. 단, 로그함수의 인자는모두 문자 하나여야 한다.

logaYZ 

= logYZ / loga

x = logY + logZ / loga



- 문제 5 :  다음 함수 들의 역함수를 구하시오

1. f(x) = log(x - 3) - 5

   

2. f(x) = 3log(x + 3) + 1

   y = 3log(x + 3) + 1

   y - 1 = 3log(x + 3)

   (y -1) / 3 = log(x + 3)

   2 ** {(y-1) / 3} = x + 3

   2 ** {(y-1) / 3} - 3 = x

   f(x) = 2 ** {(y-1) / 3} - 3

3. f(x) = 2 X 3 ** x - 1

​        



y = f(x)

x = f ** (-1) (y)



## 3. 집합과 조합론

- 집합과 조합론에 대한 약간의 설명

  - 두 집합  A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은  A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.

  - 예를 들어 모든 4의 배수는 2의 배수라는 것을 증명하려면, 4k = 2(2k)임을 보이면 되는 것이다.

  - 두 집합 A와 B가 같다는 것을증명하기 위해서는 A가 B의 부분집합이고 B가 A의 부분집합을 증명하면 된다.

  - 다음 두 집합이 같다는 것을 상세히 증명해 보자.

    A = {x|x = 2k + 1, k는 자연수}, B = {x|x = 4k + 1 혹은 x = 4k + 3, k는 자연수}

    

    -  A가 B의 부분집합이다:
    - A에 포함되는 임의의 원소 x를 가정.
    - x = 2k + 1임.
    - k가 짝수(=2t)인 경우와 홀수(=2t + 1)인 경우로 나눔.
    - 짝수인 경우 x = 2k + 1 = 2(2t) + 1 = 4t + 1로서, x는 B에 포함됨.
    - 홀수인 경우 x = 2k + 1 = 2(2t + 1) + 1 = 4t + 3로서, x는 B에 포함됨.
    - 모든 가능한 경우에 x는 B에 포함됨.



- - - B가 A의 부분집합이다.
    - B에 포함되는 임의의 원소 x를 가정
    - x = 4k + 1인 경우, x = 4k + 1 = 2(2k) + 1로서 x는 A에 포함됨.
    - x = 4k + 3인 경우, x = 4k + 3 = 2(2k + 1) + 1로서 x는 A에 포함됨.
    - 모든 가능한 경우에 x는 B에 포함됨.



- - - 위 두가지 증명에서 집합 A와 B는 같다.
  -  조합론은 경우의 수를 따지는 문제들을 보통 말한다.
  - 조합의 개수는 C를 이용하여 표현하기도 하지만(5  2) = 10과 같은 괄호 표현을 더 많이 쓴다.



### 연습 문제들

- 문제 1 : (n  k) + (n  k-1) = (n+1  k)임을 증명하라



- 문제 4 : 귀류법을 이용하여 (A - B) ^ (B - A) = 공집합임을 증명하라

- 문제 5 : 생략
- 문제 6 : 다음이 사실임을 증명하라 (벤 다이어그램 활용)

(A U B) ^ (A ^ B)**c = (A - B) U (B - A)

- 문제 7 : A + B 는 두 집합의 합집합에서 교집합을 뺀 것을 말한다. 다음 식이 항상 성립함을 증명하라

(A + B) + B = A (벤 다이어그램 활용)



- 문제 8 : 8 X 8 체스 판에 똑같은 말 두 개를 놓으려고 한다. 아무 곳에나 놓아도 되지만 한 칸에 두 개가 들어가지는 못한다. 가능한 방법은 모두 몇 가지인가?

64C2, nCr = n! / (n-r)! r!

= 32 X 63 =  2016



- 문제 9 : n개의 원소를 가진 집합의 가능한 부분집합의 종류는 2**n개임을 조합론을 이용해 증명하라.



- 문제 10 : 비밀번호를 0부터 9까지의 숫자만 가지고 만든다고 하자. 각 숫자는 최대 한번 사용할 수 있다. 4개 이상 6개 이하의 숫자를 쓸 수 있다고 할 때, 가능한 비밀번호의 가짓수는 얼마인가? 186480가지

   4개 10 x 9 X 8 X 7 = 5040

  5개 10 X 9 X 8 X 7 X 6 = 30240

  6개 10 X 9 X 8 X 7 X 6 X 5 = 151200

- 문제 11 : 원소가 m개인 집합에서 원소가 n개인 집합으로 가는 단사함수(일대일 함수)의 개수는 몇 가지인가?

nPm 

= n (n-1) ... (n-m+1)

= n! / (n-m)!



- 문제 12 : 52개의 트럼프 카드 한 세트를 이용해서 만들 수 있는 5개 카드의 조합은 몇 가지인가?

nCr = 52 X 51 X 50 X 49 X 48 = 311,875,200



- 문제 13 : 52개의 카드를 이용해서 만들 수 있는 5개 카드 조합 중 같은 무늬의 카드가 정확히 3개인 경우는 몇 가지인가? (나머지 두장의 카드도 무늬가 다르다.)

4C1 = 4, 13C3 = 13 X 12 X 11 / 6 = 286, 3C1 = 3, 13C1 = 13 13C1 = 13

580008가지



- 문제 14 : x + y + z = 100의 자연수 해는 몇 가지인가? 4851가지



99C2 = 99 X 98 / 2 = 4851



- 문제 15 : (포함 배제 원리) 5개의 원소를 가진 집합에서 3개의 원소를 가진 집합으로 가는 전사함수는 몇 가지가 있는가?

5 3

3 ** 5 + 3C1 - 3C1 X 2**5 = 150



- 문제 16 : 52개 카드에서 5개 카드 조합을 만들 때, 숫자가 같은 카드가 한 쌍도 없는 경우는 몇 가지인가?

13C5 X 4 ** 5

= 1287 X  1024

= 1,317,888

- 문제 17 : n개의 원소를 가진 배열에서 연속된 구간을 잡으려고 한다. 잡을 수 있는 가능한 구간은 몇 가지인가? 단, 구간의 크기는 1이상이다.

nC2 + n



## 4 . 기초 수식

- 약간의 설명
  - 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재한다.
  - 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 시간이 얼마나 걸릴 지 예측할 수 있다.
- 연습 문제들 : 다음 재귀식들을 O() notation 수준으로 풀어라.
  - 문제 1 : T(n) = T(n - 1) + 1

**Solution**

T(n) = T(n - 1) + 1

= T(n - 2) + 1 + 1

= T(1) + 1 + ... + 1



T(n) = O(n)



- - 문제 2 : T(n) = T(n - 1) + n

  ```markdown
  T(n) = T(n-1)+n
  = T(n-2) + (n-1) + n
  = T(n-3) + (n-2) + (n-1) + n
  ...
  = T(1) + ... + (n-1) + n
  -> 1 + ... + (n-1) + n
  O(n ** 2)
  ```

  

  

  - 문제 3 : T(n) = T(n - 1) + log n

  ```markdown
  [Solution]
  
  T(n) = T(1) + log n + log n-1 + log n-2 + ... + log2
  	<= T(1) + log n + log n + log n + ... + log n
  	<= T(1) + n log n
  T(n) = O(n log n)
  ```

  

  - 문제 4 : T(n) = T(n/2) + 1

  ```markdown
  = (T(n/4)+1) + 1
  = (T(1)+1) + 1 + ... + 1
  = 2 ** x = n
  x = log n
  T(n) = O(log n)
  ```

  

  

  - 문제 5 : T(n) = T(n/2) + n

  ```markdown
  = (T(n/4) + n/2) + ... + n
  = T(1) + 2n / n + ... + n/2 + n
  = 2n - 2
  T(n) = O(n)
  ```

  

  

  - 문제 6 : T(n) =  2T(2/n) + n => O(nlogn)
  - 문제 7 :  T(n) = 3T(n/2) + n => O(n ** log3)
  - 문제 8 : T(n) = T(n-1) + 1/n => O(logn)
  - 문제 9 : T(n) = T(n / 2) + T(n / 4) + T(n  / 6) + ... + T(n / 12) + 1 = > O(n)
  - 문제 10 : T(n) = √n X T(√n) + n  => O(nlog(logn))



## 재귀

### 연습문제들 : 다음 문제들을 푸는 재귀 알고리즘을 슈더코드로 작성하고, 정확성 증명 및 시간 복잡도 계산을 수행하라



- 문제 1 : 피보나치 수열 : F(n) = F(n - 1) + F(n - 2), F(1) = F(2) = 1

Solution

```C++
fibo(n){
    if(n <= 2) return 1
    return fibo(n-1) + fibo(n-2)
}
```

Proof)

가정 : fibo(n)을 호출하면 F(n)이 return  됨을 알 수 있다.

(1) n = 1, n = 2일때,

​	fibo(1) = 1이고, fibo(2) = 1 인데, 이는 F(1) = 1, F(2) = 1 이므로 위의 코드로 성립한다.

(2) n = k일때,

​	fibo(1) ... fibo(k-1)이 F(1) ... F(k-1)과 같다고 가장하자. 이때 F(k) = F(k-1) + F(k-2)이므로, fibo(k) = fibo(k-1) + fibo(k-2) = F(k)가 성립한다.

따라서 fibo(n)을 호출하면 F(n)이 return됨을 알 수 있다.



Time complexity)

​	T(n) = T(n - 1) + T(n - 2) + 1

​			< 2T(n - 1) + 1

​	T(n) = O(2 ** n)



- 문제 2 : Merge Sort, 크기  n인 배열을 입력으로 받아, 배열을 절반으로 두 개로 나눈 후, 각 작은 배열을 재귀적으로 정렬하고, 그 결과를 Merge한다.

  n log n

- 문제 3 :  다음 소팅 알고리즘이 실제로 소팅에 항상 성공한다는 것을 증명하라.

```c++
Stupid (A[0..n-1])
{
    if n=2 and A[0] > A[1]
        then swap A[0] and A[1]
    else
        m = ceiling(2n/3)
        Stupid(A[0..m-1])
        Stupid(A[n-m..n-1])
        Stupid(A[0..m-1])
}
```

- 문제 4 : 위의 소팅 알고리즘에서 수행하는  Swap의 횟수는 최대 몇 번인가?

O(n ** 2.7)



- 문제 5 : 어떤 배열[1...n]에 (음수 포함) 정수 값이 증가하는 순서로 저장되어 있다. A[i] = i가 되는 인덱스 i가 존재하는지 찾는 알고리즘을 슈더코드 수준으로 작성하고 정확성 증명 및 시간 복잡도 계산을 수행하라. 동일한 문제이지만, 저장된 값이 자연수로 제한되면 어떻게 풀 수 있는가?



- 문제 6 : 루트 있는 트리를 입력으로 받아 아래와 같이 출력하는 알고리즘을 작성하라. 트리의 각 노드에는 1000 미만의 자연수가 저장되어 있다. 트리의 노드 연결 관계는 다음과 같이 표현해야 한다. 아래 출력에서 루트에는 자식이 3개 있고 그 자식들 중 하나는 더 이상 자식이 없는 것임을 알 수 있을 것이다.

```c++
[030]--+--[054]-----[001]
       +--[002]
       L--[045]-----[123]
```



- 문제 7 : (어려움) 무한한 크기의 물통이 3개 있다. 초기에 각 물통에는 자연수 리터 만큼의 물이 들어 있다. 가능한 작업은 두개의 787 물통을 잡아서 그 중 많거나 같은 양의 물이 들어 있는 곳에서 작은 쪽으로 물을 부어서 작은 쪽의 물의 양을 두배로 만드는 것이다. 즉, 4리터, 3리터를 잡았다면 1리터, 6리터가 될 것이다. 입력으로 초기 물의 양을 받아서 한 물통에 들어있는 물의 양을 0리터로 만들고 싶다.(실행 시간이 많이 걸려도 좋으니) 그렇게 만드는 과정을 계산하는 알고리즘을 작성하라.



## 6 .동적 프로그래밍

### 연습문제들 : 다음 문제들을 동적 프로그래밍 알고리즘을 슈더코드로 작성하고, 정확성 증명 및 시간 복잡도 계산을 수행하라

- 문제 3 : 행렬 곱하기,  n개의 행렬을 곱하려고 한다. 크기가 a x b인 행렬과 크기가 b x c인 행렬을 곱하는 데 드는 계산량은 a x b x c라고 한다. n개의 행렬들을 곱하는데 필요한 계산량을 최소화 하는 순서를 찾는 알고리즘을 작성하라. 행렬들의 크기는 다르고, 입력으로 주어진다고 가정하라. 물론 곱하기가 가능한 크기들만 주어진다.



- 문제 4 : (약간 어려움) 배열에 정수(음수 포함)들이 저장되어 있다. 연속인 구간들 중 그 합이 가장 큰 구간을 찾는 알고리즘을 작성하라. 단, 구간의 크기는 1 이상이 허용된다.



- 문제 5 : (어려움) 배열에 정수(음수 포함)들이 저장되어 있다. 배열의 일부값들을 골라서 배열에 있는 순서대로 보면 증가하는 순서가 될 수 있다. 이러한 것들 중 가장 긴 것을 찾는 알고리즘을 작성하라.



