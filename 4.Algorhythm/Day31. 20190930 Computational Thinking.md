# Computational Thinking

**"어떤 전공도 상식선에서 이해되는 분야는 없다."**



## 0. 서론 - 프로그래밍과 논리/수학

- 프로그래밍의 어려운 점 두 가지

  - 프로그래밍 언어 문법과 라이브러리 사용
  - 논리 (Hard Logic)

- 문법과 라이브러리

  - 많이 알려진 어려운 점

  ```c++
  #include <iostream>
  #include <set>
  #include <functional>
  using namespace std;
  
  int main{}{
      set<int> a;
      
      pair<get<int>::iterator, bool> pr;
      pr = s.insert(50);   // returns result pair
      s.insert(40);
      s.insert(80);
      
      if (true == pr.second)
          cout << +pr.first << "Success!!" << endl;
      else
          cout << +pr.first << "Failure!" << endl;
  }
  ```

  

  - 위 프로그램이 무엇을 하는 것인지 처음 보는 사람은 알 수 없음
  - 능숙해지기 위해 많은 훈련이 필요하지만, 이 과정의 중요 목표는 아님
  - 프로그래밍을 최초로 배울 때 약간의 어려움이 있지만 훈련에 비례하여 실력이 느는 경향이 있음
  - 일반 상식으로 원래 알고 있는 것이 아니기 때문에 훈련의 필요성에 대해 반감이 없음

- 논리 (Hard Logic)

  - Hard vs. Soft Logic

  - 카드 문제

    - 사실 : 모든 카드의 한쪽에는 알파벳이, 다른 쪽에는 숫자가 써 있음
    - 주장 : 만약 한쪽이 D이면 반대쪽은 3
    - 주장이 사실인지 확인하기 위해 다음 카드 중 반드시 뒤집어 보아야하는 것은 몇 개이고 어느 것인가?
    - **D F 3 7**
    - 답 D 7

    

- Hard vs. Soft Logic
  - 맥주집 문제를 풀 때는 직관을 사용한 것
  - 직관은 논리적인 느낌을 주는 것
  - 직관의 장점은 (익숙한 상황에서) 빠르다는 것
  - 직관의 단점은 정확하지 않다는 것(가끔은 익숙한 상황에서도 틀림)
  - 또 다른 단점은 강한 착각을 일으킨다는 것
- 프로그래밍은 Hard Logic을 사용
  - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
  - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요
- 오해의 근원
  - Soft Logic으로 알고리즘을 이해하려고 하는 것!
  - 알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안 봤기 때문
  - 증명을 봐도 이해가 안되는 것은 직관으로 이해하려고 하기 때문
  - 가끔 직관적으로 이해되는 알고리즘이 있지만 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능



    ```markdown
p q  p -> q  ~q ~p  ~q -> ~p
T T    T     F  F       T
T F    F     F  T       T
F T    T     T  F       F
F F    T     T  T       T

p -> q 명제
q -> p 역(Converse)
~p -> ~q 이(inverse)
~q -> ~p 대우(contrapositive)

p q ~p
T F  F

p q p V q 논리합 (OR)
T T   T
T F   T
F T   T
F F   F

p q p ^ q 논리곱 (AND)
T T   T
T F   F
F T   F
F F   F

p q ~p  q -> ~p  p^(q -> ~p)
T T  F     F          F
T F  F     T          T
F T  T     T          F
F F  T     T          F

p q r  ~q  (p ^ ~q)  (p ^ ~q) -> r
T T T   F     F            T
T T F   F     F            T
T F T   T     T            T
T F F   T     T            F
F T T   F     F            T
F T F   F     F            T
F F T   T     F            T
F F F   T     F            T

    ```



- 증명

  - 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함

  - 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음

  - 증명에 대해 수많은 오해가 p -> q를 p <-> q와 혼동하는 것에서 일어남

    

  - 모든 당구공은 색이 같다는 다음 증명에서 잘못된 것은?

    - 수학적 귀납법 : P(1)이 참이고, P(n) -> P(n + 1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.
- 모든 자연수 n에 대해 당구공 n개가 들어있는 집합에서 그 집합에 포함된 당구공은 모두 색이 같다는 것을 증명함
  
    - P(1) : 당구공 1개가 들어있는 집합은 모두 색이 같음
- P(n) -> P(n + 1)을 증명하기 위해 P(n)이 참이라고 가정
  
    - 당구공 n + 1개가 들어있는 임의의 집합을 생각함
- 이 집합에서 하나를 빼명 당구공 n개가 있는 집합이 되므로 지금 상황에서 모든 당구공의 색이 같음
  
    - 방금 뺀 원소를 다시 넣고, 다른 당구공을 빼면 역시 당구공 n개가 있는 집합이 되므로 지금 상황에서도 모든 당구공의 색이 같음
- 위의 두 상황에서 처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같음을 알 수 있으므로 당구공 n+1개가 들어있는 임의의 집합은 색이 같은 것만을 포함함
  
    - 대부분의 사람들이 P(n)이 참이라고 가정할 수 없다고 반론함
- 수학적 귀납법에서 필요한 것은 P(n) -> P(n + 1)이 참임을 보이는 것 뿐이므로 P(n)이 정말로 참일 필요는 없음
    -  위 증명에서 실제로 잘못된 것은 다음 부분

      - 위의 두 상황에서 처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같음을 알 수 있으므로..

    - 처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같다는 것은 공통 부분이 있다는 것인데, 실제로 n = 1인 경우, 즉 n + 1 = 2인 경우 공통 부분이 없음



- 수학적 귀납법과 증명의 수준
  - 수학적 귀납법의 기본형 : P(1)이 참이고, P(1)이 참이고, P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수  n에 대해서 참이다.
  - 수학적 귀납법의 강한 형태 : P(1)이 참이고, P(1) ^ P(2) ^ ... ^ P(n) -> P(n + 1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.
  - 다음 함수가 1부터 x까지의 합을 계산함을 증명해 보자

```c++
int sum(int x)
{
    if (x -> 0) return 0;
    return x + sum(x-1);
}
```



- - High-level 증명에서는 1부터 x까지의 합의 정의 중 하나인 S(n) = S(n - 1) + n을 그대로 코딩한 것이므로 증명이 된 것이라고 말하는 경우가 많음
  - 상세한 증명을 하려면 단순히 "답을 맞는 것이 당연하다"라고 말하는 것으로는 충분하지 않음
    - **증명이 가능한 명제**를 만들어야 함
    - 이 경우 증명이 가능한 명제는 다음과 같음: "sum(x)가 리턴하는 값은 1 + 2 + ... + x" 의 값과 항상 같다
    - 이제 수학적 귀납법을 사용할 수 있음
    - P(1)이 참이다: "sum(1)이 리턴하는 값은 1이다."를 증명하면 됨, 실제코드에 1을 대입하면 1을 리턴함을 알 수 있음



### 1. 논리와 증명

- 문제 1: 다음 명제들이 항진명제라는 것을 진리표를 이용해서 보이시오.
  - 1. ~(~p ^ q) V q
    2. (~p V q) V (p ^ ~q)

- 문제 4 : 명제식의 변형을 통하여 다음 명제를 간소화하시오.

  - 1. (p ^ ~q) V (p ^ q)

       p^(~q V q) == p ^ T == p

    

    2. (p V ~q) ^ (~p V ~q)

       (p ^ ~p) v ~q == F V ~q == ~q

- 문제 5: 다음 명제들이 참인지 확인하시오. 단, R은 실수의 집합을 의미하고, Z는 정수의 집합을 의미한다.

- 문제 6 : (직접 증명) n이 짝수이면 3n + 5는 홀수임을 증명하라

  3(2k) + 5 = 2(3k) + 2*2 + 1 = 2(3k+2)+1

- 문제 7 : n이 홀수이면 n ** 2 + n은 짝수임을 증명하라

  (2k+1) ** 2 + (2k+1) = 4k ** 2 + 4k + 1 + 2k + 1

  = 4k ** 2 + 6k + 2 = 2(2k ** 2 + 3k + 1)



- 문제 8 : m이 짝수이고 n이 홀수이면 2m + 3n은 홀수임을 증명하라

  m = 2k, n = 2k -1

  2 * (2k) + 3 * (2k - 1)

  = 4k + 6k - 3

  = 10k - 3

  = 2(5k -1) -1

  

- 문제 9 : (대우를 증명) 자연수 n에 대해, n ** 2 + 5가 홀수이면 n은 짝수임을 증명하라

(힌트 : 명제 대신, n이 홀수이면 n ** 2 + 5은 짝수임을 증명한다.)

n = 2k + 1

(2k+1) ** 2 + 5

= 4 * k ** 2 + 4 * k + 1 + 5

2(2 * k ** 2 + 2 * k + 3) 



- 문제 10 : n ** 2이 짝수이면 n은 짝수임을 증명하라

n = 2k + 1

(2k + 1) ** 2 

= 4 * k ** 2 + 4k + 1

= 2(2k ** 2 + 2k) + 1

​						



- 문제 11 : (경우를 나누어 증명) 자연수 n에 대해 n ** 2 + 5 * n + 3은 항상 홀수임을 증명하라.

(힌트 :  n이 짝수인 경우와 홀수인 경우를 따로 증명한다.)

1. n = 2k

4 * k ** 2 + 10 * k + 3

= 2(2 * k ** 2 + 5 * k + 1) + 1

2. n = 2k + 1

4 * k ** 2 + 4 * k + 1 + 10 * k  + 3 + 5

= 2(2 * k ** 2 + 7 * k + 4) + 1



- 문제 12 : n ** 2이 3의 배수이면 n은 3의 배수임을 증명하라.

n = 3k + 1 

(3k + 1) ** 2 

= 9 * k ** 2 + 9 * k + 1

= 3(3 * k ** 2 + 3 * k) + 1

n = 3k + 2

(3k + 2) ** 2

= 9 * k ** 2 + 12 * k + 4

= 3(3 * k ** 2 + 4 * k + 1) + 1



- 문제 13 : n이 홀수이면 n ** 2을 8로 나눈 나머지는 1임을 증명하라

(힌트 : n을 4로 나눈 나머지가 1인 경우와 3인 경우로 나누어 보자)

n = 4k + 1

(4k + 1) ** 2

= 16 * k ** 2 + 8 * k + 1

(4k + 3)

16k ** 2 + 24k + 8 + 1 = 8(2k **2 + 3k + 1) + 1



- 문제 14 : 어떤 자연수를 제곱하여도 그 결과를 3으로 나눈 나머지는 2가 아님을 증명하라.

1. n = 2k

(2 * k) ** 2

= 4 * k ** 2

3(k ** 2) + k ** 2



2. n = 2k + 1

(2 * k + 1) ** 2

4 * k ** 2 + 4 * k + 1



- 문제 15 : (귀류법) 유리수와 무리수의 합은 무리수임을 증명하라.

(힌트 : 어떤 유리수와 어떤 무리수의 합이 유리수가 된다고 가정하고 모순을 이끌어 낼 수 있는가?)

Solution

Proof)

어떤 유리수와 어떤 무리수의 합이 유리수가 된다고 가정하자.

유리수 a, 무리수 b가 있고 a 와 b 의 합은 유리수 c가 된다고 하자.

a + b = c, b = c - a 가 되고, 이 때 c - a 값인 b는 유리수의 성질에 의해

유리수여야만 한다. (가정에 모순)



따라서 b가 무리수라는 가정에 모순되므로, 유리수와 무리수의 합은 유리수임을 증명할 수 있다.



- 문제 16 :  √2는 무리수임을 증명하라

√2 = b / a (a와 b는 서로소인 정수)

2 * a ** 2 = b ** 2

b ** 2는 2의 배수, b ** 2는 짝수, b는 짝수

a ** 2도 짝수, a 도 짝수

"a와 b가 서로소"에 모순 되므로 √2는 무리수이다.



- 문제 17 : log2 5 는 무리수임을 증명하라

log2 5 = b / a (a, b는 서로소)

2 ** (b / a) = 5

2 ** b = 5 ** a

유리수가 아님 그러면 무리수임!



- 문제 18 : (수학적 귀납법) 1 + 2 + 3 + ... + n = n(n + 1) / 2임을 증명하라.

n = 1일때 1(1 + 1) / 2 = 이므로 성립한다.

n = k 일때 성립한다고 가정하면

1 + ... + k = k(k + 1) / 2



n = k + 1

1 + ... + k + k + 1 = (k + 1)(k + 2) / 2

= (k + 1) * k/2 + (k + 1) * 2/2

= ((k+1) * k + 2 * (k+1)) / 2

= (k ** 2 + 3 * k + 2) / 2 = (k + 1)(k + 2) / 2



오른쪽 식에 k + 1을 넣으면 (k + 1)(k + 1 + 1) / 2

 

- 문제 19 : 1 ** 2 + 2 ** 2 + 3 ** 2 + ... + n ** 2 = n(n + 1)(2n + 1) / 6임을 증명하라.

n = k 일때 

1 ** 2 + 2 ** 2 + ... + k ** 2 + (k + 1) ** 2 =



- 문제 20 : r != 1일때, ∑n i = 0 r **i = r(n+1) - 1 / r - 1임을 증명하라.

S = r ** 0 + r ** 1 + r ** 2 + ... + r **(n)

rS = r ** 1 + r ** 2 + ... + r ** (n+1)

S - rS = r ** 0 - r ** (n+1)

(1-r)S = r ** 0 - r ** (n+1)

S = r ** (n+1) -1 / r -1 (r != 1)



- 문제 21 : 2 이상의 모든 자연수 n에 대해 n ** 3 - n은 6으로 나누어 떨어짐을 증명하라.

n(n ** 2 - 1)

= n(n - 1)(n + 1)

= (n - 1) * n * (n + 1) 



- 문제 22 : 2 이상의 모든 자연수 n에 대해 √n < 1 / √1 + 1 / √2 + ... + 1 / √n임을 증명하라.



- 문제 23 : n x n 체스판이 있다. 시작 시점에 일부 칸들이 감염되어 있다. 매 초마다 감염이 증가할 수 있다. 규칙은 다음과 같다. 어떤 감염되지 않은 칸은 상하나 좌우로 인접한 네 개의 칸들 중 2개 이상이 감염된 상태일 때 감염된다. 이 규칙에 따라 모든 칸들을 감염시키기 위해서는 초기에 n개 이상의 칸들이 감염되어 있어야 함을 증명하라.

(힌트 : 금방 떠오르는 것은 답이 아닐 가능성이 높다.)



감염조건 : 

(1) 상하좌우 2개의 칸이 감염된 경우

(2) 상하좌우 3개의 칸이 감염된 경우

(3) 상하좌우 4개의 칸이 감염된 경우

감염되고 나면 : 

(1) 주변에 2개의 칸을 감염시킬 수 있음

(2) 주변에 1개의 칸을 감염시킬 수 있음

(3) 주변에 0개의 칸을 감염시킬 수 있음

s를 감염된 칸과 감염되지 않은 칸의 경계인 길이가 1인 부분으로 정의하면, s는 증가할 수 없다.



모든 칸이 감염되었다고 생각할 경우, s의 수는 체스판의 네 모퉁이가 되어 4n개가 되고, 