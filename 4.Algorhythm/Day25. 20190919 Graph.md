# 응용 4. 그래프

#### 그래프는 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현한다.

#### 그래프는 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조

#### 선형 자료구조나 트리 자료구조로 표현하기 어려운 N : N 관계를 가지는 원소들을 표현하기에 용이하다.



## 그래프 유형

#### 무향 그래프(Undirected Graph)

#### 유향 그래프(Directed Graph)

#### 가중치 그래프(Weighted Graph)

#### 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)

#### 완전 그래프

- 정점들에 대해 가능한 모든 간선들을 가진 그래프

#### 부분 그래프

- 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프



## 인접 정점

#### 인접(Adjacency)

- 두 개의 정점에 간선이 존재(연결됨)하면 서로 인접해 있다고 한다.
- 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있다.



## 그래프 경로

#### 경로란 간선들을 순서대로 나열한 것

- 간선들 : (0, 2), (2, 4), (4, 6)
- 정점들 : 0 - 2 - 4 -6

#### 경로 중 한정점을 최대 한 번만 지나는 경로를 단순경로라 한다.

- 0 - 2 - 4 - 6, 0 - 1 - 6

#### 시작한 정점에서 끝나는 경로를 사이클(Cycle)이라고 한다.

- 1 - 3 - 5 - 1



## 그래프 표현

#### 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정

#### 인접 행렬(Adjacent matrix)

- |V|x|V| 크기의 2차원 배열을 이용해서 간선 정보를 저장
- 배열의 배열(포인터 배열)

#### 인접 리스트(Adjacent List)

- 각 정점에서 해당 정점으로 나가는 간선의 정보를 저장

#### 간선의 배열

- 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장



## 인접 행렬

#### 두 정점을 연결하는 간선의 유무를 행렬로 표현

- |V| x |V| 정방 행렬
- 행 번호와 열 번호는 그래프의 정점에 대응
- 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현



- 무향 그래프
  - i번째 행의 합 = i번째 열의 합 = Vi의 차수
- 유향 그래프
  - 행 i의 합 = Vi의 진출 차수
  - 열 i의 합 = Vi의 진입 차수



#### 인접 행렬의 단점은?



## 인접 리스트

#### 각 정점에 대한 인접 정점들을 순차적으로 표현

#### 하나의 정점에 대한 인접 정점들을 각각  노드로 하는 연결 리스트로 저장



## 문제 제시 : 친구 관계

#### 다음과 같이 친구 관계를 그래프로 표현하였다.

#### A로부터 시작해서 한 명의친구에게만 소식을 전달 할 수 있다면 최대 몇 명의 친구가 소식을 전달 받을 수 있을까?(단, 소식을 전달 받은 친구한테는 소식을 재전달할 수 없다.)

#### A로부터 시작해서 친구들에게 동시에 소식을 전달할 수 있다고 할 때, 가장 늦게 전달 받는 사람은 누구일까? (단, 친구에게 소식을 전달하는 속도는 동일하다.)



# 그래프 탐색

## 그래프 순회(탐색)

#### 그래프 순회는 비선형구조인 그래프로 표현된 모든 자료(정점)를 빠짐없이 탐색하는 것을 의미한다.



#### 두 가지 방법

- 깊이 우선 탐색(Depth First Search, DFS)
- 너비 우선 탐색(Breadth First Search, BFS)



## DFS(깊이우선탐색)

#### 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법



#### 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용



## 스택

### 스택(stack)의 특성

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조이다.
- 선형구조 : 자료 간의 관계가 1대1의 관계를 갖는다.
  - 비선형구조 : 자료 간의 관계가 1대N의 관계를 갖는다
- 마지막에 삽입한 자료를 가장 먼저 꺼낸다.
  - 후입선출( LIFO, Last -In-First-Out) 이라고 부른다.



## 스택의 구현

### 스택을 구현하기 위해서 필요한 저장소와 연산

- 자료를 선형으로 저장할 저장소
  - C언어에서는 배열을 사용할 수 있다.
  - 저장소 자체를 스택이라 부르기도 한다.
  - 스택에서 마지막 삽입된 원소의 위치를 top라 부른다.
- 연산

| push        | 저장소에 자료를 삽입(저장)한다.                |
| ----------- | ---------------------------------------------- |
| **pop**     | 저장소에서 자료를 꺼낸다. (삽입한 자료의 역순) |
| **isEmpty** | 스택이 비었는지 확인하는 연산                  |
| **peek**    | 스택의 top에 있는 item(원소)을 반환하는 연산   |



### 스택의 삽입 / 삭제 과정

- 빈 스택에 원소 A, B, C를 차례로 삽입 후 한번 삭제하는 연산과정



#### 스택의 push 알고리즘

- top은 스택에서 마지막 자료의 위치를 가리킨다.

```c
push(S, x)
    
    top <- top + 1;

	if top > STACK_SIZE
		error overflow;
	else
        S[top] <- x;
```



#### 스택의 pop 알고리즘

```c
pop( s )
    
    if top = 0
        error underflow;
	else
        top <- top - 1;
		return S[top + 1];
```



#### DFS 알고리즘 - 재귀

```c
DFS_Recursive(G, v)

	visited[ v ] <- TRUE  // v 방문 설정
    
    FOR each all w in adjacency( G, v )
    	IF visited[w] != TRUE
    		DFS_Recursive(G, w)
```

슈더 코드

```python
'''
n번 노드에 방문하면,
n을 방문한 노드로 표시

모든 노드 i에 대해,
n에 인접이고 방문하지 않은 노드면,
i로 이동
'''
```

#### DFS 알고리즘 - 반복

```c
STACK s
visited[ ]
DFS(v)
	push( s, v )
    WHILE NOT isEmpty( s )
    	v <- pop(s)
        IF NOT visited[v]
        	visit( v )
            FOR each w in adjacency( v )
            	IF NOT visited[w]
                	push(s, w)
```



## DFS 예

```c
STACK s
visited[ ]
DFS(v)
    push( s, v )
    WHILE NOT isEmpty( s )
    	v <- pop(s)
    	IF NOT visited[v]
    		visit( v )
    		FOR each w in adjacency( v )
    			IF NOT visited[w]
    				push(s, w)
```



## 연습문제 1 - DFS

#### 다음은 연결되어 있는 두 개의 정점 사이의 간선을 순서대로 나열해 놓은 것이다. 모든 정점을 깊이 우선 탐색하여 화면에 깊이우선탐색 경로를 출력하시오. 시작 정점을 1로 시작하시오.

- 1, 2, 1, 3, 2, 4, 2, 5, 4, 6, 5, 6, 6, 7, 3, 7

- 출력 결과의 예는 다음과 같다.

  - 1-2-4-6-5-7-3

  ```python
  def dfs(n, V):
      print(n)  # 방문 노드 출력
      visited[n] = 1  # n번 노드에 방문 표시
      for i in range(1, V + 1):  # 모든 노드 i에 대해
          if adj[n][i] == 1 and visited[i] == 0:  # 인접하고 미방문이면
              dfs(i, V)  # i로 이동
  
  
  V, E = map(int, input().split())
  adj = [[0] * (V + 1) for _ in range(V + 1)]  # 인접행렬 만들기
  visited = [0] * (V + 1)  # 방문 표시용
  edge = list(map(int, input().split()))
  for i in range(E):
      n1, n2 = edge[i * 2], edge[i * 2 + 1]
      adj[n1][n2] = 1
      adj[n2][n1] = 1
  dfs(1, V)
  ```

  

  - 1-3-7-6-5-2-4

  

입력

7 8

1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7

1) 인접행렬 만들기

2) 탐색 순서 출력

3) 방향성 그래프로 바꾸고 4에서



- DFS 응용
- 1에서 4번 노드에 도착할 수 있는 경로의 수 찾기

```c
// n = 1, k = 4

DFS(n, k)
    if( n == k )
        cnt++;
	else
        V[n] = 1;  //방문표시
		for i : 1 -> N
			if(M[n][i] == 1 && V[i] == 0)
                DFS(i, k);  // 인접하고 방문하지 않은 노드로 이동
		V[n] = 0;  // 방문표시 삭제
```

- 1에서 4번 노드에 도착할 수 있는 최단 거리 찾기
  - 모든 경로를 찾는 것이 기본
  - 지나온 간선의 수를 인자로 전달

```c
// 호출조건 : n = 1, k = 4, e = 0, min = INF

DFS(n, k, e)
    if( n == k )
        if( min > e )
            min = e;
	else
        V[n] = 1;  // 방문 표시
		for i : 1 -> N
			if( M[n][i] == 1 && V[i] == 0)
                DFS(i, k, e+1);  // 인접하고 방문하지 않은 노드로 이동
		V[n] = 0;  // 방문 표시 삭제
```

- 1에서 4번 노드에 도착할 수 있는 최단 거리 찾기
  - 호출을 줄이려면 중단 조건 추가

```c
// 호출조건 : n = 1, k = 4, e = 0, min = INF

DFS(n, k, e)
    if( n == k )
        if( min > e )
            min = e;
	else if(e >= min)
        return;  // 현재까지 거리가 기존의 min보다 크면 다른 경로
	else
        V[n] = 1;  // 방문 표시
		for i : 1 -> N
			if( M[n][i] == 1 && V[i] == 0)
                DFS(i, k, e+1);  // 인접하고 방문하지 않은 노드로 이동
		V[n] = 0;  // 방문 표시 삭제
```



## BFS(Breadth First Search)

#### 너비우선탐색은 탐색 시작 점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식

#### 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용함



## 큐

#### 큐(Queue)의 특성

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
  - 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조
- 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.
  - 선입선출구조(FIFO : First In First Out)



## 큐의 구조 및 기본연산

#### 큐의 선입선출 구조

#### 큐의 기본 연산

- 삽입 : enQueue
- 삭제 : deQueue



## 큐의 연산 과정

1. 공백 큐 생성 : createQueue();
2. 원소 A 삽입 : enQueue(A);
3. 원소 B 삽입 : enQueue(B);
4. 원소 반환 / 삭제 : deQueue();
5. 원소 C 삽입 : enQueue(C);
6. 원소 반환 / 삭제 : deQueue();
7. 원소 반환 / 삭제 : deQueue();



## 큐의 구현

#### 삽입 : enQueue(item)

- 마지막 원소 뒤에 새로운 원소를 삽입하기 위해

  1. rear 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 마련
  2. 그 인덱스에 해당하는 배열원소 Q[rear]에 item을 저장

  

## BFS 예

```c
BFS(G, v)  // 그래프 G, 탐색 시작점 v
    큐 생성
    시작점 v를 큐에 삽입
    점 v를 방문한 것으로 표시
    WHILE 큐가 비어있지 않은 경우
    	t <- 큐의 첫 번째 원소 변환
    	FOR t와 연결된 모든 선에 대해
    		u <- t의 인접 정점
    			u가 방문되지 않은 곳이면,
				u를 큐에 넣고, 방문한 것으로 표시
```



### swea 5247 [파이썬 S/W 문제해결 구현] 6일차 - 연산 D4

```python
def bfs(n, m):
    f = r = -1
    v = {n: 1}
    r += 1
    q[r] = n
    while f != r:
        f += 1
        n = q[f]
        t = [n - 10, n - 1, n + 1, n * 2]
        for i in range(4):
            if t[i] == m:
                return v[n]
            if 0 < t[i] <= min(1000000, M + 10):
                if not v.get(t[i]):
                    v[t[i]] = v[n] + 1
                    r += 1
                    q[r] = t[i]
                    
for tc in range(1, int(input()) + 1):
    N, M = map(int, input().split())
    q = [0] * 1000000
    r = bfs(N, M)
    print('#{} {}'.format(tc, r))
```



### swea 5248. [파이썬 S/W 문제해결 구현] 6일차 - 그룹 나누기 D3

```python
def dfs(n):
    global N
    global res
    for i in range(N):
        if not V[i]:
            if g[n][i]:
                V[i] = 1
                dfs(i)
                
for tc in range(1, int(input()) + 1):
    N, M = map(int, input().split())
    case = list(map(int, input().split()))
    res = 0
    g = [[0 for _ in range()n] for _ in range(N)]
    V = [False] * N
    for i in range(0, len(case), 2):
        r = case[i] - 1
        c = case[i + 1] - 1
        g[r][c] = 1
        g[c][r] = 1
        
    for i in range(N):
        if not V[i]:
            res += 1
            dfs(i)
    print('#{} {}'.format(tc, res))
```

